<h1>Explain Panic/Recover Mechanism in Detail</h1>

<p>
Panic and recover mechanism has been
<a href="control-flows-more.html#panic-recover">introduced before</a>,
and several panic/recover use cases are shown in
<a href="panic-and-recover-use-cases.html">the last article</a>.
This current article will explain panic/recover mechanism in detail.
Exiting phases of function calls will also be explained detailedly.
</p>

<a class="anchor" id="exiting-phase"></a>
<h3>Exiting Phases of Function Calls</h3>

<div>
<p>
In Go, a function call may undergo an exiting phase.
In the exiting phase, the deferred function calls pushed into the defer-call stack
in executing the function call will be executed (in the inverse pushing order).
When all of the deferred calls fully exit,
the exiting phase ends and the function call also fully exits.
</p>

For a function, a call to it may enter the exiting phase (or exit directly) through three ways:
<ol>
<li>
	after the call returns normally.
</li>
<li>
	when a panic occurs in the call.
</li>
<li>
	after the <code>runtime.Goexit</code> function is called and exits.
</li>
</ol>

For example, in the following code snippet,
<ul>
<li>
	a call to the function <code>f0</code> or <code>f1</code>
	will enter its existing phase after it returns normally.
</li>
<li>
	a call to the function <code>f2</code> will enter its exiting phase
	after the divided-by-zero panic happens.
</li>
<li>
	a call to the function <code>f3</code> will enter its exiting phase
	after the <code>runtime.Goexit</code> function call exits.
</li>
</ul>

<pre class="line-numbers"><code class="language-go">import (
	"fmt"
	"runtime"
)

func f0() int {
	var x = 1
	defer fmt.Println("exits normally:", x)
	x++ // reachable
	return x
}

func f1() {
	var x = 1
	defer fmt.Println("exits normally:", x)
	x++ // reachable
}

func f2() {
	var x, y = 1, 0
	defer fmt.Println("exits for panicking:", x)
	x = x / y // panic
	x++       // unreachable
}

func f3() int {
	x := 1
	defer fmt.Println("exits for Goexiting:", x)
	x++
	runtime.Goexit()
	return x+x // unreachable
}
</code></pre>

<p>
</p>
</div>

<a class="anchor" id="function-call-assosiations"></a>
<h3>Assosiating Panics and Goexit Signals of Function Calls</h3>
<div>

<p>
When a panic occurs in a function call, we say the panic starts associating with the function call.
When the <code>runtime.Goexit</code> function is called in a function call,
we say a Goexit signal starts associating with the function call.
A panic and a Goexit signal are independent of each other.
As explained in the last section,
associating either a panic or a Goexit signal with a funciton call
will make the function call enter its exiting phase immediately.
</p>

<p>
We have learned that <a href="control-flows-more.html#panic-recover">panics can be recovered</a>.
However, there are no ways to cancel a Goexit signal.
</p>

At any give time, a function call may associate with at most one unrecovered panic.
When an unrecovered new panic occurs in a function call and
the function call has already accociated with an old unrecovered panic,
the new one will replace the old one to be the associating unrecovered panic of the function call.
For example, in the following program, the recovered panic is panic 3,
which is the last panic associating with the <code>main</code> function call.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	defer func() {
		fmt.Println(recover()) // 3
	}()
	
	defer panic(3) // will replace panic 2
	defer panic(2) // will replace panic 1
	defer panic(1) // will replace panic 0
	panic(0)
}
</code></pre>

<p>
</p>

<p>
As Goexit signals can't be cancelled,
arguing whether a function call may associate with at most one or more than one Goexit signal is unecessary.
</p>

<p>
Although it is unusual, there might be multiple unrecovered panics coexisting in a goroutine at a time.
Each one associates with one non-exited function call in the call stack of the goroutine.
When a nested call exits and it is still associating with an unrecovered panic,
then the unrecovered panic will spread to (and associate with) the nesting call (the caller of the nested call).
That says, if there was an old unrecovered panic associating with the nesting call before,
the old one will be replaced by the spread one.
This will make the nesting call enter (if it hasn't entered) its exiting phase immediately.
So, when a goroutine exits, there may be at most one unrecovered panic
associating with the entry function call of the goroutine.
If a goroutine exits with an unrecovered panic, the whole program crashes.
The information of the unrecovered panic will be reported when the program crashes.
</p>

<p>
When a deferred call is invoked by an exiting call,
there is neither a panic nor Goexit signals associating with the deferred call initially.
Surely, panics might occur or the <code>runtime.Goexit</code> function might be called later
in the process of executing the deferred call, so panics and Goexit signals might associate with the deferred call later.
This is the reason why there might be multiple unrecovered panics coexisting in a goroutine sometimes.
</p>

The following example program will crash if it runs,
because the panic 2 is still not recovered when the new goroutine exits.

<pre class="line-numbers"><code class="language-go">package main

func main() {
	// The new goroutine.
	go func() {
		// The anonymous deferred call.
		// When it exits, the panic 2 will spread to
		// the entry function call of the goroutine,
		// and replace the panic 0. The panic 2 will
		// never be recovered.
		defer func() {
			// As explained in the last example,
			// panic 2 will replace panic 1.
			defer panic(2)
			
			// When the anonymous function exits,
			// panic 1 will spread to (and associate
			// with) the anonymous deferred call.
			func () {
				panic(1)
				// Once the panic 1 occurs, there will
				// be two unrecovered panics coexisting
				// in the new goroutine. One (panic 0)
				// associates with the entry function
				// call of the new goroutine, the other
				// (panic 1) accosiates with the
				// current anonymous function call.
			}()
		}()
		panic(0)
	}()
	
	select{}
}
</code></pre>

The output (when the above program is compiled with the standad Go compiler v1.13):
<pre class="output"><code>panic: 0
	panic: 1
	panic: 2

goroutine 5 [running]:
...
</code></pre>

<p>
The format of the output is not perfect, it is prone to make some people think that the panic 0 is the final unrecovered panic.
</p>

<p>
Similarly, when a nested call exits and it is still associating with a Goexit signal,
then the Goexit signal will also spread to (and associate with) the nesting call.
This will make the nesting call enter (if it hasn't entered) its exiting phase immediately.
</p>

The above has mentioned that a panic and a Goexit signal are independent of each other.
In other words, an unrecovered panic should not cancel a Goexit signal,
and a Goexit signal should not shadow an unrecovered panic or be cancelled.
However, both of the current official Go compiler (gc, v1.13) and gccgo (v8.0)
don't implement this rule correctly.
For example, the following program should crash but it doesn't
if it is compiled with the current versions of gc and gccgo.

<pre class="line-numbers"><code class="language-go">package main

import "runtime"

func main() {
	c := make(chan struct{})
	go func() {
		defer close(c)
		// The Goexit signal shadows the
		// "bye" panic, but it should not.
		defer runtime.Goexit()
		panic("bye")
	}()
	<-c
}
</code></pre>

<p>
</p>

The following is another example (borrowed from <a href="https://github.com/golang/go/issues/29226">this issue</a>)
neither gc nor gccgo compiles it correctly.
The example program should not print <code>unreachable</code> but it does
if it is compiled with the current versions of gc and gccgo.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "runtime"

func f() {
	defer func() {
		recover()
	}()
	panic("to cancel Goexit")
	runtime.Goexit()
}

func main() {
	c := make(chan struct{})
	go func() {
		defer close(c)
		f()
		fmt.Println("unreachable")
	}()
	<-c
}
</code></pre>

<p>
The problems in the current versions gc and gccgo <a href="https://github.com/golang/go/issues/29226">will be fixed later</a>.
</p>

</div>

<a class="anchor" id="some-recovers-are-no-ops"></a>
<h3>Some <code>recover</code> Calls Are No-Ops</h3>
<div>

The builtin <code>recover</code> funciton must be called at proper places to take effect.
Otherwise, the calls are no-ops.
For example, none of the <code>recover</code> calls in the following exmaple recover the <code>bye</code> panic.

<pre class="line-numbers"><code class="language-go">package main

func main() {
	defer func() {
		defer func() {
			recover() // no-op
		}()
	}()
	defer func() {
		func() {
			recover() // no-op
		}()
	}()
	func() {
		defer func() {
			recover() // no-op
		}()
	}()
	func() {
		defer recover() // no-op
	}()
	func() {
		recover() // no-op
	}()
	recover()       // no-op
	defer recover() // no-op
	panic("bye")
}
</code></pre>

<p>
</p>

We have already known that the following <code>recover</code> call takes effect.

<pre class="line-numbers"><code class="language-go">package main

func main() {
	defer func() {
		recover() // take effect
	}()

	panic("bye")
}
</code></pre>

<p>
</p>


Then why don't those <code>recover</code> calls in the first example in the current section take effect?
Let's read <a href="https://golang.org/ref/spec#Handling_panics">Go specification</a>:

<div class="alert alert-success">
The return value of <code>recover</code> is <code>nil</code> if any of the following conditions holds:
<ul>
<li>panic's argument was nil;</li>
<li>the goroutine is not panicking;</li>
<li>recover was not called directly by a deferred function.</li>
</ul>
</div>

<p>
There is <a href="panic-and-recover-use-cases.html#avoid-verbose">an example</a>
showing the first condition case in the last article.
</p>

<p>
Most of the <code>recover</code> calls in the first example in the current section satisfy
either the second or the third conditions mentioned in Go specification,
except the first one. Yes, the current descriptions are not precise yet.
It is still <a href="https://go-review.googlesource.com/c/go/+/189377">being improved</a> now.
</p>

In fact, the current Go specification also doesn't explain why the second
<code>recover</code> call, which is expected to recover panic 1,
in the following example doesn't take effect.

<pre class="line-numbers"><code class="language-go">// This program exits without panic 1 being recoverd.
package main

func demo() {
	defer func() {
		defer func() {
			recover() // this one recovers panic 2
		}()

		defer recover() // no-op

		panic(2)
	}()
	panic(1)
}

func main() {
	demo()
}
</code></pre>

<p>
What Go specification doesn't mention is that,
at any given time, only the newest unrecovered panic is recoverable.
In other words, each <code>recover</code> call is viewed as an attempt
to recover the newest unrecovered panic in the currrent goroutine.
This is why the second <code>recover</code> call in the above example is a no-op.
</p>


OK, now, let's try to make an explanation on which <code>recover</code> calls will take effect:
<div class="alert alert-info">
A <code>recover</code> call takes effect only if the caller of
the <code>recover</code> call is a deferred call and
the caller of the deferred call associates with the newest unrecovered panic.
A successful <code>recover</code> call disassociates the
newest unrecovered panic from its associating function call,
and returns the value passed to the <code>panic</code> call which produced the newest unrecovered panic. 
</div>

</div>





